"""
Deterministic Reporting Workflow Endpoint

Part of Workflow-First Architecture (Phase 1):
- Explicit parameters (no TP orchestration)
- Direct specialist invocation
- Full context loading (WorkBundle pattern)
- Auditable execution tracking
- Optional recipe-driven execution (parameterized templates)

Recipe Integration:
- When recipe_id provided, validates parameters against recipe schema
- Generates execution context from recipe execution_template
- Passes context to ReportingAgentSDK.execute_recipe()
- When no recipe, executes standard reporting flow
"""

from typing import Optional, Dict, Any
from uuid import UUID
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel

from app.utils.jwt import verify_jwt
from app.utils.supabase_client import supabase_admin_client as supabase
from agents_sdk.reporting_agent_sdk import ReportingAgentSDK
from agents_sdk.work_bundle import WorkBundle
from services.recipe_loader import RecipeLoader, RecipeValidationError
from shared.session import AgentSession
import logging

router = APIRouter(prefix="/work/reporting", tags=["workflows"])
logger = logging.getLogger(__name__)


class ReportingWorkflowRequest(BaseModel):
    """Deterministic reporting workflow parameters."""
    basket_id: str
    task_description: str
    output_format: Optional[str] = "markdown"  # markdown, pptx, json
    priority: Optional[int] = 5

    # Recipe integration (optional)
    recipe_id: Optional[str] = None  # Recipe UUID or slug
    recipe_parameters: Optional[Dict[str, Any]] = None  # User-customized parameters
    reference_asset_ids: Optional[list[str]] = None  # User-uploaded assets


class ReportingWorkflowResponse(BaseModel):
    """Reporting workflow execution result."""
    work_request_id: str
    work_ticket_id: str
    agent_session_id: str
    status: str  # pending, running, completed, failed
    outputs: list[dict]  # work_outputs generated by agent
    execution_time_ms: Optional[int]
    message: str
    recipe_used: Optional[str] = None  # Recipe slug if recipe-driven


@router.post("/execute", response_model=ReportingWorkflowResponse)
async def execute_reporting_workflow(
    request: ReportingWorkflowRequest,
    user: dict = Depends(verify_jwt)
):
    """
    Execute deterministic reporting workflow.

    Flow (Standard):
    1. Validate permissions (workspace, basket, trial limits)
    2. Load context (WorkBundle: blocks + assets + config)
    3. Create work_request + work_ticket (tracking)
    4. Execute ReportingAgentSDK with context
    5. Return structured outputs

    Flow (Recipe-Driven):
    1. Load recipe by ID/slug
    2. Validate user parameters against recipe schema
    3. Generate execution context from recipe template
    4. Create work_request with recipe linkage
    5. Execute ReportingAgentSDK.execute_recipe() with context
    6. Return structured outputs

    Args:
        request: Reporting workflow parameters
        user: Authenticated user from JWT

    Returns:
        Reporting workflow execution result with outputs

    Raises:
        401: Authentication failed
        403: Permission denied or trial limit exceeded
        404: Basket or recipe not found
        400: Invalid recipe parameters
        500: Execution error
    """
    user_id = user.get("sub") or user.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Invalid user token")

    logger.info(
        f"[REPORTING WORKFLOW] Starting: user={user_id}, basket={request.basket_id}, "
        f"recipe={request.recipe_id}"
    )

    try:
        # Step 1: Validate basket access and get workspace
        basket_response = supabase.table("baskets").select(
            "id, workspace_id, name"
        ).eq("id", request.basket_id).single().execute()

        if not basket_response.data:
            raise HTTPException(status_code=404, detail="Basket not found")

        basket = basket_response.data
        workspace_id = basket["workspace_id"]

        # TODO: Add workspace permission check (verify user has access)
        # TODO: Add trial limit check (work_requests count)

        # Step 2: Get or create reporting agent session (persistent per basket)
        reporting_session = await AgentSession.get_or_create(
            basket_id=request.basket_id,
            workspace_id=workspace_id,
            agent_type="reporting",
            user_id=user_id,
        )

        logger.info(
            f"[REPORTING WORKFLOW] Agent session: {reporting_session.id}"
        )

        # Step 3: Recipe-driven execution (if recipe_id provided)
        recipe = None
        execution_context = None
        validated_params = None

        if request.recipe_id:
            logger.info(f"[REPORTING WORKFLOW] Loading recipe: {request.recipe_id}")

            loader = RecipeLoader()

            # Load recipe by ID or slug
            try:
                # Try as UUID first
                recipe = await loader.load_recipe(recipe_id=request.recipe_id)
            except Exception:
                # Fall back to slug (handles both RecipeValidationError and UUID parsing errors)
                recipe = await loader.load_recipe(slug=request.recipe_id)

            logger.info(f"[REPORTING WORKFLOW] Loaded recipe: {recipe.name} (v{recipe.version})")

            # Validate parameters
            try:
                validated_params = loader.validate_parameters(
                    recipe=recipe,
                    user_parameters=request.recipe_parameters or {}
                )
                logger.info(f"[REPORTING WORKFLOW] Validated parameters: {validated_params}")
            except RecipeValidationError as e:
                raise HTTPException(
                    status_code=400,
                    detail=f"Recipe parameter validation failed: {str(e)}"
                )

            # Generate execution context
            execution_context = loader.generate_execution_context(
                recipe=recipe,
                validated_parameters=validated_params
            )

        # Step 4: Create work_request (for trial tracking & billing)
        work_request_data = {
            "workspace_id": workspace_id,
            "basket_id": request.basket_id,
            "requested_by_user_id": user_id,
            "request_type": f"recipe_{recipe.slug}" if recipe else "reporting_workflow",
            "task_intent": recipe.name if recipe else request.task_description,
            "parameters": {
                "output_format": request.output_format,
                "recipe_used": recipe.slug if recipe else None,
                "recipe_parameters": validated_params if recipe else None,
            },
            "priority": "normal",
        }

        # Add recipe linkage if recipe-driven
        if recipe:
            work_request_data["recipe_id"] = recipe.id
            work_request_data["recipe_parameters"] = validated_params
            work_request_data["reference_asset_ids"] = request.reference_asset_ids or []

        work_request_response = supabase.table("work_requests").insert(
            work_request_data
        ).execute()
        work_request_id = work_request_response.data[0]["id"]

        # Step 5: Create work_ticket (execution tracking)
        work_ticket_data = {
            "work_request_id": work_request_id,
            "agent_session_id": reporting_session.id,
            "workspace_id": workspace_id,
            "basket_id": request.basket_id,
            "agent_type": "reporting",
            "status": "pending",
            "metadata": {
                "workflow": "recipe_reporting" if recipe else "deterministic_reporting",
                "task_description": request.task_description,
                "output_format": request.output_format,
                "recipe_slug": recipe.slug if recipe else None,
                "recipe_id": recipe.id if recipe else None,
            },
        }
        work_ticket_response = supabase.table("work_tickets").insert(
            work_ticket_data
        ).execute()
        work_ticket_id = work_ticket_response.data[0]["id"]

        logger.info(
            f"[REPORTING WORKFLOW] Created: work_request={work_request_id}, "
            f"work_ticket={work_ticket_id}"
        )

        # Step 6: Load context (WorkBundle pattern)
        blocks_response = supabase.table("blocks").select(
            "id, content, semantic_type, state, created_at, metadata"
        ).eq("basket_id", request.basket_id).in_(
            "state", ["ACCEPTED", "LOCKED", "CONSTANT"]
        ).order("created_at", desc=True).limit(50).execute()

        substrate_blocks = blocks_response.data or []

        # Load reference assets (user-uploaded) if provided
        reference_assets = []
        if request.reference_asset_ids:
            assets_response = supabase.table("documents").select(
                "id, title, document_type, metadata, file_url"
            ).in_("id", request.reference_asset_ids).execute()
            reference_assets = assets_response.data or []

        # Create WorkBundle
        context_bundle = WorkBundle(
            work_request_id=work_request_id,
            work_ticket_id=work_ticket_id,
            basket_id=request.basket_id,
            workspace_id=workspace_id,
            user_id=user_id,
            task=execution_context["deliverable_intent"].get("purpose") if execution_context else request.task_description,
            agent_type="reporting",
            priority=f"p{request.priority}",
            substrate_blocks=substrate_blocks,
            reference_assets=reference_assets,
            agent_config=execution_context if execution_context else {},
        )

        logger.info(
            f"[REPORTING WORKFLOW] WorkBundle: {len(substrate_blocks)} blocks, "
            f"{len(reference_assets)} assets"
        )

        # Step 7: Update work_ticket to running
        supabase.table("work_tickets").update({
            "status": "running",
            "started_at": "now()",
        }).eq("id", work_ticket_id).execute()

        # Step 8: Execute reporting agent
        reporting_sdk = ReportingAgentSDK(
            basket_id=request.basket_id,
            workspace_id=workspace_id,
            work_ticket_id=work_ticket_id,
            session=reporting_session,
            bundle=context_bundle,
        )

        import time
        start_time = time.time()

        if recipe:
            # Recipe-driven execution
            logger.info(f"[REPORTING WORKFLOW] Executing recipe: {recipe.name}")
            result = await reporting_sdk.execute_recipe(
                recipe_context=execution_context,
                claude_session_id=reporting_session.claude_session_id,
            )
        else:
            # Standard reporting execution (free-form)
            logger.info(f"[REPORTING WORKFLOW] Executing standard reporting")
            result = await reporting_sdk.generate(
                report_type=request.task_description or "custom_report",
                format=request.output_format or "pdf",
                topic=request.task_description or "Report",
                requirements=request.task_description,
                claude_session_id=reporting_session.claude_session_id,
            )

        execution_time_ms = int((time.time() - start_time) * 1000)

        # Step 9: Update work_ticket to completed
        supabase.table("work_tickets").update({
            "status": "completed",
            "completed_at": "now()",
            "metadata": {
                "workflow": "recipe_reporting" if recipe else "deterministic_reporting",
                "execution_time_ms": execution_time_ms,
                "output_count": result.get("output_count", 0),
                "recipe_slug": recipe.slug if recipe else None,
            },
        }).eq("id", work_ticket_id).execute()

        logger.info(
            f"[REPORTING WORKFLOW] Execution complete: {result.get('output_count', 0)} outputs "
            f"in {execution_time_ms}ms"
        )

        return ReportingWorkflowResponse(
            work_request_id=work_request_id,
            work_ticket_id=work_ticket_id,
            agent_session_id=reporting_session.id,
            status="completed",
            outputs=result.get("work_outputs", []),
            execution_time_ms=execution_time_ms,
            message=f"{'Recipe' if recipe else 'Reporting'} workflow executed successfully: {result.get('output_count', 0)} outputs generated",
            recipe_used=recipe.slug if recipe else None,
        )

    except HTTPException:
        raise
    except RecipeValidationError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.exception(f"[REPORTING WORKFLOW] Failed: {e}")

        # Update work_ticket to failed if it exists
        if 'work_ticket_id' in locals():
            try:
                supabase.table("work_tickets").update({
                    "status": "failed",
                    "completed_at": "now()",
                    "error_message": str(e),
                    "metadata": {
                        "error_type": type(e).__name__,
                        "recipe_id": recipe.id if recipe and 'recipe' in locals() else None,
                    },
                }).eq("id", work_ticket_id).execute()
            except Exception as update_error:
                logger.error(f"Failed to update work_ticket: {update_error}")

        raise HTTPException(
            status_code=500,
            detail=f"Reporting workflow execution failed: {str(e)}"
        )
